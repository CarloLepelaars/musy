"""Basic building blocks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['BASE_NOTES', 'CHROMATIC_NOTES', 'INTERVALS', 'NOTE_MAPPING', 'INTERVAL_NAMES', 'INTERVAL_HALF_STEPS',
           'STEPS_TO_INTERVAL', 'STEPS_TO_INTERVAL_FULL', 'INTERVAL_TYPES', 'SCALES', 'INV_SCALES', 'Note', 'Interval',
           'Chord', 'PolyChord', 'Scale']

# %% ../nbs/00_core.ipynb 3
import io
import numpy as np
from fastcore.all import *
import scipy.io.wavfile as wav
from IPython.display import Audio
from itertools import combinations
from mingus.core import chords as mingus_chords, notes as mingus_notes

# %% ../nbs/00_core.ipynb 6
BASE_NOTES = ["C", "D", "E", "F", "G", "A", "B"]
CHROMATIC_NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
INTERVALS = ["1", "b2", "2", "b3", "3", "4", "#4", "5", "b6", "6", "b7", "7"]
NOTE_MAPPING = {
    "C": 0,
    "C#": 1,
    "Db": 1,
    "D": 2,
    "D#": 3,
    "Eb": 3,
    "E": 4,
    "Fb": 4,
    "E#": 5,
    "F": 5,
    "F#": 6,
    "Gb": 6,
    "G": 7,
    "G#": 8,
    "Ab": 8,
    "A": 9,
    "A#": 10,
    "Bb": 10,
    "B": 11,
    "Cb": 11,
    "B#": 0
}
INTERVAL_NAMES = {
    "1": "unison",
    "b2": "minor second",
    "2": "major second",
    "b3": "minor third",
    "3": "major third",
    "4": "perfect fourth",
    "#4": "augmented fourth",
    "b5": "diminished fifth",
    "5": "perfect fifth",
    "b6": "minor sixth",
    "6": "major sixth",
    "b7": "minor seventh",
    "7": "major seventh",
    "8": "octave",
    "b9": "minor ninth",
    "9": "major ninth",
    "#9": "augmented ninth",
    "b10": "minor tenth",
    "10": "major tenth",
    "b11": "minor eleventh",
    "11": "major eleventh",
    "#11": "augmented eleventh",
    "b12": "minor twelfth",
    "12": "major twelfth",
    "b13": "minor thirteenth",
    "13": "major thirteenth",
}
INTERVAL_HALF_STEPS = {
    "1": 0,
    "b2": 1,
    "2": 2,
    "b3": 3,
    "3": 4,
    "4": 5,
    "#4": 6,
    "b5": 6,
    "5": 7,
    "b6": 8,
    "6": 9,
    "b7": 10,
    "7": 11,
    "8": 12,
    "b9": 13,
    "9": 14,
}
STEPS_TO_INTERVAL = {
    0: "1",
    1: "b2",
    2: "2",
    3: "b3",
    4: "3",
    5: "4",
    6: "b5",
    7: "5",
    8: "b6",
    9: "6",
    10: "b7",
    11: "7",
    12: "8",
    13: "b9",
    14: "9",
    15: "b10",
    16: "10",
    17: "11",
    18: "#11",
    19: "12",
    20: "b13",
    21: "13",
    22: "b14",
    23: "14",
    24: "15"
}

STEPS_TO_INTERVAL_FULL = {
    0: "unison",
    1: "minor second",
    2: "major second",
    3: "minor third",
    4: "major third",
    5: "perfect fourth",
    6: "tritone",
    7: "perfect fifth",
    8: "minor sixth",
    9: "major sixth",
    10: "minor seventh",
    11: "major seventh",
    12: "octave",
    13: "minor ninth",
    14: "major ninth",
    15: "minor tenth",
    16: "major tenth",
    17: "perfect eleventh",
    18: "augmented eleventh",
    19: "perfect twelfth",
    20: "minor thirteenth",
    21: "major thirteenth",
    22: "minor fourteenth",
    23: "major fourteenth",
    24: "double octave"
}
INTERVAL_TYPES = {
    0: "Perfect Consonant",   # Unison
    1: "Sharp Dissonant",          # Minor Second
    2: "Mild Dissonant",          # Major Second
    3: "Soft Consonant", # Minor Third
    4: "Soft Consonant", # Major Third
    5: "Contextual",         # Perfect Fourth
    6: "Neutral",          # Tritone/Augmented Fourth/Diminished Fifth
    7: "Perfect Consonant",   # Perfect Fifth
    8: "Soft Consonant", # Minor Sixth
    9: "Soft Consonant", # Major Sixth
    10: "Mild Dissonant",         # Minor Seventh
    11: "Sharp Dissonant",         # Major Seventh
}



SCALES = {"major": ["1", "2", "3", "4", "5", "6", "7"],
          "minor": ["1", "2", "b3", "4", "5", "b6", "b7"],
          "natural minor": ["1", "2", "b3", "4", "5", "b6", "b7"],
          "dorian": ["1", "2", "b3", "4", "5", "6", "b7"],
          "phrygian": ["1", "b2", "b3", "4", "5", "b6", "b7"],
          "lydian": ["1", "2", "3", "#4", "5", "6", "7"],
          "mixolydian": ["1", "2", "3", "4", "5", "6", "b7"],
          "aeolian": ["1", "2", "b3", "4", "5", "b6", "b7"],
          "locrian": ["1", "b2", "b3", "4", "5", "b6", "7"],
          "melodic minor": ["1", "2", "b3", "4", "5", "6", "7"],
          "dorian b2": ["1", "b2", "b3", "4", "5", "6", "b7"],
          "lydian augmented": ["1", "2", "3", "#4", "#5", "6", "7"],
          "lydian b7": ["1", "2", "3", "#4", "5", "6", "b7"],
          "mixolydian #11": ["1", "2", "3", "#4", "5", "6", "b7"],
          "locrian n2": ["1", "2", "b3", "4", "5", "b6", "7"],
          "altered": ["1", "b2", "b3", "3", "b5", "b6", "b7"],
          "aeolian dominant": ["1", "2", "3", "4", "5", "b6", "b7"],
          "phrygian dominant": ["1", "b2", "3", "4", "5", "b6", "b7"],
          "harmonic minor": ["1", "2", "b3", "4", "5", "b6", "7"],
          # TODO Harmonic minor/major and modes
          "pentatonic major": ["1", "2", "3", "5", "6"],
          "pentatonic minor": ["1", "b3", "4", "5", "b7"],
          "pentatonic blues": ["1", "b3", "4", "b5", "5", "b7"],
          "pentatonic neutral": ["1", "2", "4", "5", "b7"],
          "blues": ["1", "b3", "4", "5", "b7"],
          }

INV_SCALES = {tuple(intervals): [name for name, scale_intervals in SCALES.items() if scale_intervals == intervals] 
               for intervals in SCALES.values()}

# %% ../nbs/00_core.ipynb 11
class Note(BasicRepr):
    def __init__(self, note: str, oct: int = 4):
        assert isinstance(oct, int) and oct > 0, f"Octave must be a positive integer, got oct={oct}."
        store_attr()
        # Transform note to uppercase
        if isinstance(note, str):
            note = note[0].upper() + note[1:]
            assert mingus_notes.is_valid_note(note), f"Note '{note}' is not valid"
            self.note = self.postprocess_note(mingus_notes.remove_redundant_accidentals(note))

    @staticmethod
    def postprocess_note(note: str):
        """ Get rid of unnecessary accidentals."""
        if note == "B#": note = "C"
        elif note == "E#": note = "F"
        elif note == "Cb": note = "B"
        elif note == "Fb": note = "E"
        elif note.endswith("##"):
            note = BASE_NOTES[BASE_NOTES.index(note[0])+1]
        elif note.endswith("bb"):
            note = BASE_NOTES[BASE_NOTES.index(note[0])-1]
        return str(note)
    
    def __str__(self): return self.note
    def __int__(self): return NOTE_MAPPING[str(self)]
    def rel(self): return self.oct * 12 + int(self)
    def __eq__(self, other): return self.rel() == other.rel()
    def __ne__(self, other): return self.rel() != other.rel()
    def __lt__(self, other): return self.rel() < other.rel()
    def __le__(self, other): return self.rel() <= other.rel()
    def __gt__(self, other): return self.rel() > other.rel()
    def __ge__(self, other): return self.rel() >= other.rel()

# %% ../nbs/00_core.ipynb 21
@patch
def __add__(self:Note, other):
    """Add n semitones to a note."""
    octave_change = (other + int(self)) // 12
    return Note(CHROMATIC_NOTES[(int(self) + other) % 12], oct=self.oct + octave_change)

@patch
def __mod__(self:Note, other):
    """Add n whole notes."""
    return self + other * 2

# %% ../nbs/00_core.ipynb 31
@patch
def __sub__(self:Note, other):
    """Subtract n semitones from a note."""
    octave_change = (other + int(self)) // 12
    return Note(CHROMATIC_NOTES[(int(self) - other) % 12], oct=self.oct - octave_change)

@patch
def __floordiv__(self:Note, other):
    """Subtract n whole notes"""
    return self - other * 2

# %% ../nbs/00_core.ipynb 40
class Interval:
    def __init__(self, note1: Note, note2: Note):
        store_attr()
        self.notes = [note1, note2]
        self.semitones = self.set_semitones()
    
    @property
    def short(self): return STEPS_TO_INTERVAL[abs(self.semitones) % 25]
    @property
    def long(self): return STEPS_TO_INTERVAL_FULL[abs(self.semitones) % 25]

    def set_semitones(self):
        # TODO Handle Note("B", oct=4) & Note("C", oct=6) unison bug. Fix negative intervals and upper extensions
        oct_diff = self.note2.oct - self.note1.oct
        diff = (int(self.note2)+1 - (int(self.note1)+1) + 12) % 12
        return (diff + (oct_diff * 12) + (12 if diff == 0 and oct_diff > 0 else 0) + 1) % 25 - 1

    def __repr__(self): return f"{str(self.long)} ({str(self.short)})"
    def __eq__(self, other): return self.semitones == other.semitones
    def __ne__(self, other): return not self.semitones == other.semitones
    def __lt__(self, other): return self.semitones < other.semitones
    def __le__(self, other): return self.semitones <= other.semitones
    def __gt__(self, other): return self.semitones > other.semitones
    def __ge__(self, other): return self.semitones >= other.semitones
    def __abs__(self): 
        c = Interval(self.note1, self.note2)
        c.semitones = abs(c.semitones)
        return c

# %% ../nbs/00_core.ipynb 42
@patch
def interval(self:Note, other:Note): return Interval(self, other)

@patch
def __and__(self:Note, other:Note): return self.interval(other)

# %% ../nbs/00_core.ipynb 60
@patch
def type(self:Interval): return INTERVAL_TYPES[abs(self.semitones) % 12]

# %% ../nbs/00_core.ipynb 71
@patch
def minor(self:Note): return self - 3

# %% ../nbs/00_core.ipynb 74
@patch
def major(self:Note): return self + 3

# %% ../nbs/00_core.ipynb 81
@patch
def play(self:Note, length=1): return Audio(data=self.get_audio_bytes(length))

# %% ../nbs/00_core.ipynb 90
class Chord(BasicRepr):
    def __init__(self, notes: List[Note]):
        self.notes = [Note(n) if isinstance(n, str) else n for n in notes]
        self.s_notes = [str(n) for n in self.notes]
        self.short_s_notes = [f"{n.note}{n.oct}" for n in self.notes]
        self.first = self.notes[0]
        self.s_first = str(self.first)

    def names(self) -> list[str]: return mingus_chords.determine(self.s_notes)
    def name(self): return self.names()[0] if self.names() else "No chord found."

    @classmethod
    def from_short(cls, c: str): return cls(mingus_chords.from_shorthand(c)) 

    def __repr__(self): return f"Chord: '{self.name()}'. Notes: {self.short_s_notes}"
    def __add__(self, other): return Chord([n + other for n in self.notes])
    def __sub__(self, other): return Chord([n - other for n in self.notes])
    def __mod__(self, other): return Chord([n % other for n in self.notes])
    def __floordiv__(self, other): return Chord([n // other for n in self.notes])
    def __iter__(self) -> list[str]: return iter(self.notes)
    
    def _compare_notes(self, other, op): return all(op(n1, n2) for n1, n2 in zip(self.notes, other.notes))
    def __eq__(self, other): return self.first == other.first and self._compare_notes(other, lambda x, y: x == y)
    def __ne__(self, other): return not self == other
    def __lt__(self, other): return self.first < other.first or (self.first == other.first and self._compare_notes(other, lambda x, y: x < y))
    def __le__(self, other): return self.first < other.first or (self.first == other.first and self._compare_notes(other, lambda x, y: x <= y))
    def __gt__(self, other): return self.first > other.first or (self.first == other.first and self._compare_notes(other, lambda x, y: x > y))
    def __ge__(self, other): return self.first > other.first or (self.first == other.first and self._compare_notes(other, lambda x, y: x >= y))


class PolyChord(Chord):
    def __init__(self, chords: list[Chord]):
        self.chords = chords
        super().__init__([note for chord in chords for note in chord.notes])
    def __repr__(self): return f"PolyChord: '{'|'.join([c.name() for c in self.chords])}'. Notes: {self.short_s_notes}"

# %% ../nbs/00_core.ipynb 105
@patch
def __mul__(self:Note, other: Note):
    return Chord([self, other])

@patch
def __mul__(self:Chord, other):
    if isinstance(other, Note):
        return Chord(self.notes + [other])
    elif isinstance(other, Chord):
        return PolyChord([self, other])
    else:
        raise ValueError("Chord objects can only be multiplied with Note or other Chord objects")

# %% ../nbs/00_core.ipynb 110
@patch
def invert(self:Chord, n: int = 1):
    assert n > 0 and n < len(self.s_notes), f"Invalid inversion '{n}' for chord with '{len(self.s_notes)}' notes."
    return Chord(self.notes[n:] + [Note(str(note), oct=note.oct + 1) for note in self.notes[:n]])

@patch
def invert(self:PolyChord, n: int = 1):
    return PolyChord([c.invert(n) for c in self.chords])

# %% ../nbs/00_core.ipynb 114
@patch
def intervals(self:Chord):
    return [Interval(n1, n2) for n1, n2 in zip(self.notes, self.notes[1:])]

# %% ../nbs/00_core.ipynb 119
@patch
def get_audio_array(self:Chord, length=1):
    return np.sum([n.get_audio_array(length) for n in self.notes], axis=0)

@patch
def play(self:Chord, length=1): 
    return Audio(self.get_audio_array(length), rate=44100)

# %% ../nbs/00_core.ipynb 128
class Scale:
    def __init__(self, name: str):
        self.name = name.lower()
        self.intervals = SCALES.get(self.name, "scale not found.")

    @classmethod
    def available_scales(cls): return list(SCALES.keys())
    
    @classmethod
    def from_intervals(cls, name: str, intervals: list[str]):
        """Create a custom scale from a list of intervals."""
        for i in intervals:
            assert i in list(INTERVAL_NAMES), f"Interval '{i}' not valid. Available intervals: '{list(INTERVAL_NAMES.keys())}'"
        custom_scale = cls(name)
        custom_scale.intervals = intervals
        return custom_scale
    
    def __repr__(self): return f"Scale: {self.name.title()}. Intervals: {self.intervals}"
    def __eq__(self, other): return self.intervals == other.intervals
    def __ne__(self, other): return not self == other
    def __iter__(self) -> list[str]: return iter(self.intervals)

# %% ../nbs/00_core.ipynb 142
@patch
def get_notes(self:Scale, root, oct=4):
    """Get the notes of a scale from a root note."""
    root = Note(root, oct=oct) if isinstance(root, str) else root
    return [root + int(INTERVAL_HALF_STEPS[i]) for i in self.intervals]

# %% ../nbs/00_core.ipynb 148
@patch
def get_diatonic_chords(self:Scale, root, min_notes=3):
    assert min_notes > 1, "min_notes must be greater than 1."
    notes = self.get_notes(root)
    return [Chord(combo) for n in range(min_notes, len(notes)+1) for combo in combinations(notes, n)]

# %% ../nbs/00_core.ipynb 152
@patch
def get_interval_names(self:Scale, short=False):
    return self.intervals if short else [INTERVAL_NAMES[i] for i in self.intervals]

# %% ../nbs/00_core.ipynb 158
@patch
def get_audio_array(self:Scale, root, oct=4, length=0.3):
    notes = self.get_notes(root, oct=oct)
    octave = Note(root, oct=oct+1).get_audio_array(length=length)
    return np.concatenate([n.get_audio_array(length) for n in notes] + [octave])

@patch
def play(self:Scale, root, oct=4, length=0.3): 
    return Audio(self.get_audio_array(root, oct=oct, length=length), rate=44100)

# %% ../nbs/00_core.ipynb 164
@patch
def get_triads(self:Scale, root):
    """Get all triads in scale starting from root note."""
    notes = self.get_notes(root)
    return [Chord([notes[i], 
                  Note(str(notes[(i+2)%7]), oct=notes[i].oct + (i+2)//7),
                  Note(str(notes[(i+4)%7]), oct=notes[i].oct + (i+4)//7)]) 
            for i in range(len(notes))]

# %% ../nbs/00_core.ipynb 166
@patch
def play_triads(self:Scale, root):
    """Play all triads in scale starting from root note."""
    return Audio(np.concatenate([c.get_audio_array() for c in self.get_triads(root)]), rate=44100)

# %% ../nbs/00_core.ipynb 171
@patch
def get_sevenths(self:Scale, root):
    """Get all seventh chords in scale starting from root note."""
    notes = self.get_notes(root)
    return [Chord([notes[i], 
                  Note(str(notes[(i+2)%7]), oct=notes[i].oct + (i+2)//7),
                  Note(str(notes[(i+4)%7]), oct=notes[i].oct + (i+4)//7),
                  Note(str(notes[(i+6)%7]), oct=notes[i].oct + (i+6)//7)]) 
            for i in range(len(notes))]

# %% ../nbs/00_core.ipynb 174
@patch
def play_sevenths(self:Scale, root):
    """Play all seventh chords in scale starting from root note."""
    return Audio(np.concatenate([c.get_audio_array() for c in self.get_sevenths(root)]), rate=44100)
